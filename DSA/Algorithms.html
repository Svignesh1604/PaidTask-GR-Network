
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DSA Tutorial - Home</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <nav class="topnav">
    <div class="logo" style="font-family: sans-serif;">Gowthamraj Network</div>
    <a href="javascript:void(0);" class="icon" onclick="toggleMenu()">
      <div class="hamburger">
        <div class="bar"></div>
        <div class="bar"></div>
        <div class="bar"></div>
      </div>
    </a>
    <div class="nav-links" id="navLinks">
      <a href="index.html" >Home</a>
      <a href="Introduction to Data Structures.html">Introduction to Data Structures</a>
      <a href="Pointers and Memory Concepts.html">Pointers and Memory Concepts</a>
      <a href="Linear Data Structures.html">Linear Data Structures</a>
      <a href="Non-Linear Data Structures.html">Non-Linear Data Structures</a>
      <a href="Algorithms.html">Algorithms</a>
      <a href="Practice and Interview Preparation.html">Practice and Interview Preparation</a>
      
    </div>
  </nav>

  <div class="sidebar">
    <a href="#q1">Graph Traversal Algorithms</a>
    <a href="#q2">Searching Algorithms</a>
    <a href="#q3">Searching Algorithms with example</a>
    <a href="#q4">Sorting Algorithms</a>
    

  </div>


 <div class="main-content">

  <div class="section" id="q1">

<h3 class="highlight">Graph Traversal Algorithm</h3>
  <p>In this tutorial, we will learn all techniques by using which we can traverse all the vertices of the graph. Traversing means examining all nodes and vertices of a graph. There are two standard methods by using which we can traverse graphs:</p>
  <ul>
    <li>Breadth First Search</li>
    <li>Depth First Search</li>
  </ul>


  <h3>Breadth First Search (BFS) Algorithm</h3>
  <p>Breadth First Search is a graph traversal algorithm that starts traversing graph from root node and explores all neighboring nodes. Then, it selects nearest node and explores all unexplored nodes. The algorithm follows same process for each of nearest nodes until it finds goal.</p>
  
  <h3>Algorithm</h3>
  <pre>
Step 1: SET STATUS = 1 (ready state) for each node N in G.
Step 2: Enqueue starting node A & set STATUS = 2 (waiting state).
Step 3: Repeat steps 4 and 5 until queue is empty.
Step 4: Dequeue node N. Process it & set STATUS = 3.
Step 5: Enqueue all neighbors of N that are in ready state (STATUS=1) & set STATUS = 2.
Step 6: Exit.
  </pre>
  
  <div class="example">
    <p><strong>Example:</strong> Consider graph G shown below. Calculate minimum path P from node A to node E.</p>
    <div class="graph-diagram">
      <img src="YOUR_IMAGE_URL_FOR_BFS_GRAPH" alt="Graph Example BFS">
    </div>
    <p><strong>Solution:</strong> Minimum path can be found by applying BFS starting at A and ending at E:<br>
    A → B → C → E</p>
  </div>

  <h3>Depth First Search Algorithm</h3>
  <p>DFS algorithm starts with initial node of graph G and goes deeper and deeper until we find goal node or node which has no children. The data structure used in DFS is stack.</p>
  
  <h3>Algorithm</h3>
  <pre>
Step 1: SET STATUS = 1 (ready state) for each node N in G.
Step 2: Push starting node A on stack & set STATUS = 2 (waiting state).
Step 3: Repeat steps 4 and 5 until stack is empty.
Step 4: Pop top node N. Process it & set STATUS = 3.
Step 5: Push on stack all neighbors of N that are in ready state (STATUS=1) & set STATUS = 2.
Step 6: Exit.
  </pre>

  <h3 class="highlight">Spanning Tree</h3>
  <p>If we have a graph containing V vertices and E edges, then graph can be represented as G(V,E). If we create a spanning tree from above graph, then spanning tree would have same number of vertices as the graph but vertices are not equal to edges (spanning tree edges = no. of edges of graph).</p>
  <div class="graph-diagram">
    <img src="YOUR_IMAGE_URL_FOR_SPANNING_TREE" alt="Spanning Tree Example">
  </div>

  <section>
  <h3>Minimum Spanning Tree</h3>
  <p>The minimum spanning tree is one whose sum of edge weights is minimum.</p>
  <div class="graph-diagram">
    <img src="YOUR_IMAGE_URL_FOR_MIN_SPANNING" alt="Minimum Spanning Tree">
  </div>
  <p>In above tree, total edge weight is less, therefore minimum spanning tree is a tree having edge weight = 10.</p>
  
  <h3 class="highlight">Properties of Spanning Tree</h3>
  <ul>
    <li>A connected graph can contain more than one spanning tree.</li>
    <li>All possible spanning trees have same number of vertices as graph minus 1.</li>
    <li>Spanning tree does not contain any cycles.</li>
    <li>If you remove an edge from spanning tree, it becomes disconnected.</li>
    <li>If two edges have same weight, there can be more than one minimum spanning tree.</li>
    <li>If all edges have distinct weights, there is only one unique spanning tree.</li>
  </ul>
</section>

<h3 class="highlight">Applications of Spanning Tree</h3>

<ul><li>
  <p><strong>Building a network :</strong> Suppose there are many routers in network connected that it forms a loop.</p><br></li>
 <li> <p><strong>Clustering :</strong>Clustering means that grouping set of objects in such way that similiar objects belong to some group than to different group.our goal is to divide the n objects into k groups such that distance between different groups gets maximised.</p><br>
 </li></ul>


  </div>
  <div class="section" id="q2">
<h2>Searching Algorithm</h2>

<p>* Searching is a process of finding some particular element in list . if the element is present in the list, then process is called successful and process returns location of that element,otherwise search is called unsuccessful.</p><br>
 There are two methods widely used as below<br>

 <ul><li>Linear Search</li>
<li>Binary search</li></ul>

<h2>Algorithm - Linear Search (A, N, VAL)</h2>
    <ol>
        <li>[INITIALIZE] Set POS = -1</li>
        <li>[INITIALIZE] Set I = 1</li>
        <li>Repeat step 4 while I &lt;= N</li>
        <li>
            If A[I] = VAL<br>
            &nbsp;&nbsp;Set POS = I<br>
            &nbsp;&nbsp;Print POS<br>
            &nbsp;&nbsp;Go to step 6<br>
            [End of IF]<br>
            Set I = I + 1<br>
            [End of Loop]
        </li>
        <li>
            If POS = -1<br>
            &nbsp;&nbsp;Print "VALUE IS NOT PRESENT IN ARRAY"<br>
            [End of IF]
        </li>
        <li>Exit</li>
    </ol>


     <h3>Complexity of Linear Search</h3>
    <table>
        <tr>
            <th>Complexity</th>
            <th>Best case</th>
            <th>Average case</th>
            <th>Worst case</th>
        </tr>
        <tr>
            <td>Time</td>
            <td>O(1)</td>
            <td>O(n)</td>
            <td>O(n)</td>
        </tr>
        <tr>
            <td>Space</td>
            <td colspan="3">O(1)</td>
        </tr>
    </table>


    <h3>C Program of Linear Search</h3>
    <pre>
#include &lt;stdio.h&gt;
void main() {
    int a[10] = {10, 23, 40, 1, 2, 0, 14, 13, 10, 9};
    int item, flag;
    printf("Enter item which is to be searched\n");
    scanf("%d", &item);
    for (int i = 0; i &lt; 10; i++) {
        if (a[i] == item) {
            flag = i + 1;
            break;
        } else {
            flag = 0;
        }
    }
    if (flag != 0)
        printf("Item found at location %d\n", flag);
    else
        printf("Item not found\n");
}
    </pre>
    <h4>Output:</h4>
    <pre>
Enter item which is to be searched
20
Item not found
Enter item which is to be searched
23
Item found at location 2
    </pre>


 <h2 class="highlight">Binary Search</h2>
    <p>
        Binary search is a search technique which works efficiently on sorted lists.
        It follows divide and conquer approach by comparing with the middle element.
    </p>
    <h3>Binary Search Algorithm (A, lower-bound, upper-bound, VAL)</h3>
    <ol>
        <li>[INITIALIZE] Set BEG = lower-bound, END = upper-bound, POS = -1</li>
        <li>Repeat steps 3 and 4 while BEG &lt;= END</li>
        <li>Set MID = (BEG + END)/2</li>
        <li>
            If A[MID] = VAL<br>
            &nbsp;&nbsp;Set POS = MID<br>
            &nbsp;&nbsp;Print POS<br>
            &nbsp;&nbsp;Go to step 6<br>
            Else If A[MID] > VAL<br>
            &nbsp;&nbsp;Set END = MID - 1<br>
            Else<br>
            &nbsp;&nbsp;Set BEG = MID + 1
        </li>
        <li>
            If POS = -1<br>
            &nbsp;&nbsp;Print "VALUE IS NOT PRESENT IN ARRAY"
        </li>
        <li>Exit</li>
    </ol>


     <h3>Complexity of Binary Search</h3>
    <table>
        <tr>
            <th>Sr. No.</th>
            <th>Performance</th>
            <th>Complexity</th>
        </tr>
        <tr>
            <td>1</td>
            <td>Worst case</td>
            <td>O(log n)</td>
        </tr>
        <tr>
            <td>2</td>
            <td>Best case</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>3</td>
            <td>Average case</td>
            <td>O(log n)</td>
        </tr>
        <tr>
            <td>4</td>
            <td>Space complexity</td>
            <td>O(1)</td>
        </tr>
    </table>


 </div><br> 


  <div class="section" id="q3">

    <h2>Example of Searching Algorithms</h2>

   <h3>Example of Binary Search</h3>
    <p>
        Let us consider array a[] = {5, 7, 8, 13, 19, 20, 23}<br>
        Find location of item 23 in the array.
    </p>
    <p>In 1st step:</p>
    <pre><code>
BEG = 0
END = 6
MID = 3
a[MID] = a[3] = 13 &lt; 23
    </code></pre>
    <p>In 2nd step:</p>
    <pre><code>
BEG = MID + 1 = 4
END = 6
MID = 5
a[MID] = a[5] = 20 &lt; 23
    </code></pre>
    <p>In 3rd step:</p>
    <pre><code>
BEG = MID + 1 = 6
END = 6
MID = 6
a[MID] = a[6] = 23
   </code> </pre>

   <h2>C Program: Binary Search</h2>
  <pre><code>
#include &lt;stdio.h&gt;

int binary_search(int arr[], int beg, int end, int item);

void main() {
    int arr[10] = {5,16,19,20,23,45,56,78,90,100};
    int item, location = -1;
    printf("Enter the item which you want to search:\n");
    scanf("%d", &item);
    location = binary_search(arr, 0, 9, item);
    if(location != -1)
        printf("Item found at location %d\n", location);
    else
        printf("Item not found\n");
}

int binary_search(int arr[], int beg, int end, int item) {
    int mid;
    while(beg <= end) {
        mid = (beg + end)/2;
        if(arr[mid] == item)
            return mid + 1;
        else if(arr[mid] < item)
            beg = mid + 1;
        else
            end = mid - 1;
    }
    return -1;
}
</code> </pre>

<div class="output">
    Output:<br>
    Enter item which you want to search<br>
    19<br>
    Item found at location 2
  </div>


  </div><br>

  <div class="section" id="q4">

<h2 class="highlight">Sorting Algorithm</h2>

  <h3>1) Bubble Sort Algorithm</h3>
  <p>
    Bubble sort algorithm is a simple sorting algorithm. Bubble sort works by repeatedly swapping adjacent elements until they are in the desired order. It is called a bubble sort because movement of array elements is just like movement of air bubbles in the water: bubbles rise up to the surface. Similarly, the array elements in bubble sort move up to their correct positions in each iteration.
  </p>
  <p>
    It is not suitable for large data sets as its average and worst-case complexity is <strong>O(n<sup>2</sup>)</strong>, where n is the number of items.
  </p>
  <p>
    Bubble sort is majorly used where:
    <ul>
      <li>Complexity does not matter.</li>
      <li>Simple and short code is preferred.</li>
    </ul>
  </p>

  <h3> Implementation of Bubble sort :-</h3><br>
  <p>C language implementation</p>
  <pre><code>
    # include<stdio.h>
      void print(int a[],int n)
      {
        int i;
        for(i=o;i<=n;i++)
        {
          printf("%d",a[i]);
        }
      } void bubble (int a[], int n)

3

int is jetemp

for ( i = 0; in ;it+)

Σ

for (j=0+); j<=n;j++)

if(a(j) * a[i])

temp = a[i];

a[j] = a[j] * j

a[j] = temp;

}

}

80

void main()

int i, temp;

in + 9[5] =\ 10,35,32,13,26\ :

int n = size of (a) / size of (90) ;

printf ("Before sorting anay elements are in");

print (a, b)

bubble (a, n)

printf ( "ln after sorting array elementsー1n");

print (a,n);

}
</code></pre>

<div class="output">
    Output:<br>
    Before sorting array elements are -<br>
    10 35 32 13 26<br>
    After sorting array elements are -<br>
    10 13 26 32 35.<br>
  </div>

  <section class="section">
  <h2>Bucket Sort Algorithm</h2>

  <div class="highlight">
    The data items in bucket sort are distributed in the form of buckets.
  </div>

  <p class="regular-text">
    Bucket sort is a sorting algorithm that separates elements into multiple groups called <strong>buckets</strong>. 
    These elements are then sorted within each bucket using another sorting algorithm (like insertion sort), 
    and finally concatenated to produce the sorted array.
  </p>

  <h3>Advantages</h3>
  <ul class="adj-list">
    <li>Reduces number of comparisons</li>
    <li>Asymptotically fast with uniform distribution</li>
  </ul>

  <h3>Limitations</h3>
  <ul class="adj-list">
    <li>Not always stable</li>
    <li>High cost with large arrays</li>
    <li>Not in-place (requires extra space)</li>
  </ul>

  <div class="definition">
    <div class="definition-title">Time Complexity</div>
    <table>
      <tr><th>Case</th><th>Time</th></tr>
      <tr><td>Best</td><td>O(n + k)</td></tr>
      <tr><td>Average</td><td>O(n + r)</td></tr>
      <tr><td>Worst</td><td>O(n²)</td></tr>
    </table>
    <p class="note">Space Complexity: O(n)</p>
  </div>

  <div class="box">Stable: Depends</div>

  <div class="code-block">
    <pre class="language-c">
#include &lt;stdio.h&gt;

void bucketSort(int a[], int n) {
  int max = getMax(a, n);
  int bucket[max];
  for (int i = 0; i <= max; i++) bucket[i] = 0;
  for (int i = 0; i < n; i++) bucket[a[i]]++;
  for (int i = 0, j = 0; i <= max; i++) {
    while (bucket[i]-- > 0) a[j++] = i;
  }


void printArr (int a[],int n)

}

for (int i=0; i<=n; i++)

printf("%d", a[i]);

int main ()

int a[] = {54, 12, 84, 57, 69, 41, 9.5}; int n = size of (a) / size of a());

printf ("Befere sorting array elements are:th");

printArr(a, n);

printf ("In After sorting array elements are:\h");

print Arr (a, n);
    </pre>
  </div>

  <div class="output">
    
Before sarting array elements are:-<br>

54 12  84 57 69 41 5<br>

 After surting amay elements are :-5 9 12 41 54 57 69 84<br>

  </div>
</section>

<section class="section">
  <h2>Heap Sort Algorithm</h2>

  <p class="regular-text">
    Heap sort processes elements by creating a <strong>Max-Heap</strong> or <strong>Min-Heap</strong> and then 
    repeatedly extracts the root (largest or smallest) to build a sorted array.
  </p>

  <div class="definition">
    <div class="definition-title">What is a Heap?</div>
    A heap is a complete binary tree where each parent node is greater (or smaller) than its children.
  </div>

  <h3>Algorithm</h3>

  <pre><code>Heap Sort (arr)

Build MaxHeap (arr)

For i = length (cirr) to 2

swap arr [1] with arr[i]

heap-size [arr] = heap-size [arr]? 1

Max Heapify (arr, 1)

End.
</code></pre>
<h3>Build Max Heap(arr):</h3><br>
<pre><code>
  
Build Maxheap (arr)

heap-size (arr) = length (ar)

for i length (arr)/2 to 1.

Max Heapify (arr, i)

Find.

</code></pre>

  <div class="definition">
    <div class="definition-title">Time Complexity</div>
    <table>
      <tr><th>Case</th><th>Time</th><th>Space</th></tr>
      <tr><td>Best</td><td>O(n log n)</td><td>O(1)</td></tr>
      <tr><td>Average</td><td>O(n log n)</td><td>O(1)</td></tr>
      <tr><td>Worst</td><td>O(n log n)</td><td>O(1)</td></tr>
    </table>
  </div>

  <div class="code-block">
    <h3>Implementation Of heap Sort</h3>
    <pre class="language-c">
      #include <stido.h>
        <p>/* function to heapify a Subtree. Here is 'i' the inder of root node in array al), and 'n' is size of heap */</p><br>
void heapify(int a[], int n, int i) {
  int largest = i;
  int left = 2 * i + 1;
  int right = 2 * i + 2;

  if (left < n && a[left] > a[largest]) largest = left;
  if (right < n && a[right] > a[largest]) largest = right;
  if (largest != i) {
    swap(&a[i], &a[largest]);
    heapify(a, n, largest);
  }
}

void heapsort ( m + a(J, 9n + n)

for(int i=n/2-1 ;i>0, 1)

heapify (a, n, i)

for (int ien-1; izo; i--).

{ int temp = a[0];

a[n] = a[1] * 3

9[1] = temp;

heapify (a, i, 0);

} void printarr (int arr \ J, m + h )

for(int i=0; i<=n;tti)

}

printf("%d", arr[i]);

printf("");

} int main ()

یint a[] = \{48, 10, 23, 43, 28, 26, 1\}

int n = size of (a)/size of (a[0]);

printf ("Befere sorting array elements are-In');

printArr (a, n) ;

heap sort (a, n) ;

printf("\n After sorting array elements are -\n" ) ;

print Arr (a, n)

return 0;
    </pre>

    <div class="output">
      Before sorting array elements are :-

48

10

23

43

25

26 1<br>

After surting array elements are -<br>

10 23 26 25 43

48
    </div>
  </div>
</section>

<section class="section">
  <h2>Insertion Sort Algorithm</h2>

  <p class="regular-text">
    Insertion sort works like arranging playing cards. It picks one element at a time and inserts it in its correct 
    position in the sorted portion.
  </p>

  <ul class="adj-list">
    <li>Simple and easy to implement</li>
    <li>Efficient for small data sets</li>
    <li>Adaptive for nearly sorted data</li>
  </ul>

  <div class="definition">
    <div class="definition-title">Time & Space Complexity</div>
    <table>
      <tr><th>Case</th><th>Time</th><th>Space</th></tr>
      <tr><td>Best</td><td>O(n)</td><td>O(1)</td></tr>
      <tr><td>Average</td><td>O(n²)</td><td>O(1)</td></tr>
      <tr><td>Worst</td><td>O(n²)</td><td>O(1)</td></tr>
    </table>
  </div>

  <div class="code-block">
    <pre class="language-c">
      <h3> Implemantations of insertion Sort</h3><br>
      #include <stdio.h>
void insert(int a[], int n) {
  int i, j, temp;
  for (i = 1; i < n; i++) {
    temp = a[i];
    j = i - 1;
    while (j >= 0 && a[j] > temp) {
      a[j + 1] = a[j];
      j--;
    }
    a[j + 1] = temp;
  }
}

void print Arr (int af], int n)

anti;

7oc(i = 0; i < n; i + 1)

printf ("%d", a[i]);

2

Σ int main()



int a[] = { 12,31, 25, 8, 32, 17};

int n = size of (a) / size of a[0]);

printf ("Before sorting amay elements are-\n");

pintArr (a, n);

insert (a, n);

printf("\n After sorting array elements are-\n");

printArr (a, n);

return 0;
}
    </pre>
    <div class="output">
      Before sorting array elements are-<br>

12 31 25 8 32

17<br>

After sarting array elements are <br>-12 17 25 31 32
    </div>
  </div>
</section>

<section class="section">
  <h2>Merge Sort Algorithm</h2>

  <p class="regular-text">
    Merge sort is a divide-and-conquer algorithm. It splits the array into halves, sorts each half recursively, 
    and merges the sorted halves.
  </p>

  <div class="definition">
    <div class="definition-title">Time & Space Complexity</div>
    <table>
      <tr><th>Case</th><th>Time</th><th>Space</th></tr>
      <tr><td>Best</td><td>O(n log n)</td><td>O(n)</td></tr>
      <tr><td>Average</td><td>O(n log n)</td><td>O(n)</td></tr>
      <tr><td>Worst</td><td>O(n log n)</td><td>O(n)</td></tr>
    </table>
  </div>

  <div class="code-block">
    <pre class="language-c">
      <h3>Implemantations merge Sort</h3><br>
     /* function of merge the subirrays of a[]*/

 void merge (int a[], int beg, int mid, int end)



int i,j,k;

int n = mid-bog+1;

int na end - mid;

int Left Array [ni], Right Array [n²];

/* copy data to temp arrays */

for (int i=0; ixnigits)

Left Array [i] = af beg ti]s

for (int j=0; j < n 2 jj++)

Right Array [j] = a[mid +1 + j];

i=0;

j = 0;

k = beg;

while (i<=n1 && j<=n2)

iF(LeftArray [i]<= RightArray [j])
{

a [k] = LeftArray[i];

i++;

else

{

[K]=RightArray[j];

i++;

}
}
k++;
while(i<=n1)
{
a[k]=leftArray[i];
i++;
k++;
}
while(j<=n2)
{
a[k]=RightArray[j];

j++;
k++;

}
}



   
    </pre>
  </div>
</section>



</div>


  

  </div>
  
</div>

  <footer>
    <p>© 2025 Gowthamraj Network | DSA Tutorial</p>
  </footer>

  <script>
    function toggleMenu() {
      document.getElementById("navLinks").classList.toggle("show");
    }

    const navLinks = document.querySelectorAll('.nav-links a');
    const currentPage = window.location.pathname.split("/").pop(); // gets "index.html", etc.

    navLinks.forEach(link => {
      const href = link.getAttribute('href');
      if (href === currentPage) {
        link.classList.add('active');
      }
    });
  </script>
</body>

</html>